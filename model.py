# -*- coding: utf-8 -*-
"""M.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19WwysVPYYqsCDKoNaidI7Qd-H3gVPsNu
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import category_encoders as ce
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor

from google.colab import files
uploaded = files.upload()

import lightgbm as lgb
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.linear_model import LinearRegression
from lightgbm import LGBMRegressor
from xgboost import XGBRegressor

file_path = "model.xlsx"
df = pd.read_csv(file_path)
df.head()

df.tail()

df.shape

df.info

df.describe

df.isnull().sum()

df.duplicated().sum()

df=df.drop_duplicates()

df.duplicated().sum()

df.shape

df.columns

df.dtypes

for col  in df.columns:
    print(f"value counts for {col}:")
    print(df[col].value_counts(dropna=False))
    print('\n' , "*" * 40 , '\n')

for col in df.columns:
    top = df[col].value_counts().head(10) #tail(10)
    top.plot.bar()
    plt.title(col)
    plt.xticks(rotation=45)
    plt.show()

df_no_outliers=df.copy()

df.shape

df_no_outliers.shape

for col in ['Bedrooms','Bathrooms','Price','Area','Level']:
    Q1=df[col].quantile(0.25)
    Q3=df[col].quantile(0.75)
    IQR=Q3-Q1
    lower=Q1-1.5*IQR
    upper=Q3+1.5*IQR
    df_no_outliers=df_no_outliers[(df_no_outliers[col]>=lower)&(df_no_outliers[col]<=upper)]

df.columns

sns.boxplot(x=df['Price'])

sns.boxplot(x=df_no_outliers['Price'])

sns.boxplot(x=df['Bedrooms'])

sns.boxplot(x=df_no_outliers['Bedrooms'])

sns.boxplot(x=df['Bathrooms'])

sns.boxplot(x=df_no_outliers['Bathrooms'])

sns.boxplot(x=df['Area'])

sns.boxplot(x=df_no_outliers['Area'])

sns.boxplot(x=df['Level'])

sns.boxplot(x=df_no_outliers['Level'])



df_no_outliers.shape

df_no_outliers.dtypes

cat=['City','Delivery_Term','Payment_Option','Furnished','Type']
for i in cat:
    print(i ,  df[i].nunique())

cat=['City','Delivery_Term','Payment_Option','Furnished','Type']
for i in cat:
    print(i ,"\n" , df[i].unique())

df_no_outliers.shape

df.shape

df_model = df_no_outliers.copy()
df_cleaned = df_no_outliers.copy()

df_model.shape

df_cleaned.shape

label_encoders = {}
categorical_columns = ["City", "Type", "Furnished", "Delivery_Term"]

for col in categorical_columns:
    le = LabelEncoder()
    df_cleaned[col] = le.fit_transform(df_cleaned[col])
    label_encoders[col] = le
df.head()

df_cleaned.dtypes

df_cleaned["Price_per_sqm"] = df_cleaned["Price"] / df_cleaned["Area"]

features = ["Type", "Bedrooms", "Bathrooms", "Area", "Furnished", "Level", "Delivery_Term", "City", "Price_per_sqm"]
target = "Price"

features

target

X = df_cleaned[features]
y = df_cleaned[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

X.shape

y.shape

#  تدريب النموذج  LG
from sklearn.linear_model import LinearRegression
lg=LinearRegression()
lg.fit(X_train, y_train)

#  التقييم
y_pred = lg.predict(X_test)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

#  عرض النتائج
print(f"\n تقييم النموذج:")
print(f" R² Score: {r2:.4f}")
print(f" MAE: {mae:,.2f} EGP")
print(f" RMSE: {rmse:,.2f} EGP")

#  تدريب النموذج RF
rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

#  التقييم
y_pred = rf.predict(X_test)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

#  عرض النتائج
print(f"\n تقييم النموذج:")
print(f" R² Score: {r2:.4f}")
print(f" MAE: {mae:,.2f} EGP")
print(f" RMSE: {rmse:,.2f} EGP")





import numpy as np
import pandas as pd
import re
from difflib import get_close_matches

#  القيم الصحيحة المدخلة من المستخدم
city_list = label_encoders['City'].classes_.tolist()
property_types = label_encoders['Type'].classes_.tolist()
furnished_options = label_encoders['Furnished'].classes_.tolist()
delivery_terms = label_encoders['Delivery_Term'].classes_.tolist()

def correct_spelling(user_input, valid_options, cutoff=0.7):
    """تصحيح الأخطاء الإملائية"""
    matches = get_close_matches(user_input.lower(), [v.lower() for v in valid_options], n=1, cutoff=cutoff)
    return next((v for v in valid_options if v.lower() == matches[0]), None) if matches else None

def safe_input_with_correction(prompt, valid_options):
    """إدخال نصي مع التصحيح التلقائي"""
    while True:
        value = input(prompt).strip().title()
        if not re.match("^[a-zA-Z &]+$", value):
            print(" Please enter text using English letters only.")
            continue
        if value.lower() in [v.lower() for v in valid_options]:
            return next(v for v in valid_options if v.lower() == value.lower())

        suggestion = correct_spelling(value, valid_options)
        if suggestion:
            confirm = input(f" Did you mean '{suggestion}'? (Y/N): ").strip().lower()
            if confirm == 'y':
                return suggestion
        print(f" Invalid input. Available options: {', '.join(valid_options)}")

def safe_numeric_input(prompt, dtype=float, min_val=None):
    """إدخال رقمي آمن"""
    while True:
        try:
            value = dtype(input(prompt))
            if min_val is not None and value < min_val:
                print(f" Please enter a value greater than {min_val}.")
            else:
                return value
        except ValueError:
            print(" Please enter a valid number.")

def encode_input(column_name, value):
    """تحويل المدخلات النصية إلى قيم مشفرة"""
    if column_name in label_encoders:
        return label_encoders[column_name].transform([value])[0]
    else:
        print(f" Error: '{value}' is not a valid option for {column_name}.")
        return None

def get_user_input():
    print("\n Enter property details:")

    city_name = safe_input_with_correction(" City: ", city_list)
    property_type = safe_input_with_correction(" Property Type: ", property_types)
    furnished_status = safe_input_with_correction(" Furnished? (Yes/No): ", furnished_options)
    delivery_term = safe_input_with_correction(" Delivery Condition: ", delivery_terms)

    area = safe_numeric_input(" Area (sqm): ", float, 1)
    bathrooms = safe_numeric_input(" Number of bathrooms: ", int, 0)
    bedrooms = safe_numeric_input(" Number of bedrooms: ", int, 0)
    level = safe_numeric_input(" Floor level: ", int, 0)

    #  تحويل المدخلات النصية إلى القيم المشفرة
    city_encoded = encode_input('City', city_name)
    property_type_encoded = encode_input('Type', property_type)
    furnished_status_encoded = encode_input('Furnished', furnished_status)
    delivery_term_encoded = encode_input('Delivery_Term', delivery_term)

    #  التأكد من أن جميع القيم تم ترميزها بنجاح
    if None in [city_encoded, property_type_encoded, furnished_status_encoded, delivery_term_encoded]:
        print(" Error: One or more inputs are invalid. Please re-enter the details.")
        exit()

    #  البحث عن متوسط سعر المتر في نفس المدينة باستخدام القيم المشفرة
    city_avg_price_per_sqm = df_cleaned[df_cleaned["City"] == city_encoded]["Price_per_sqm"].mean()
    if np.isnan(city_avg_price_per_sqm):
        city_avg_price_per_sqm = df_cleaned["Price_per_sqm"].mean()

    user_data = pd.DataFrame({
        'Type': [property_type_encoded],
        'Bedrooms': [bedrooms],
        'Bathrooms': [bathrooms],
        'Area': [area],
        'Furnished': [furnished_status_encoded],
        'Level': [level],
        'Delivery_Term': [delivery_term_encoded],
        'City': [city_encoded],
        'Price_per_sqm': [city_avg_price_per_sqm]
    })

    return user_data, area

#  تشغيل الكود
user_input, area = get_user_input()
print("\n Data successfully recorded!")

predicted_price = rf.predict(user_input)[0]
price_per_sqm = predicted_price / area

#  طباعة النتائج
print("RF")
print(f"\n السعر المتوقع للعقار: {predicted_price:,.2f} EGP")
print(f" سعر المتر المربع التقريبي: {price_per_sqm:,.2f} EGP")

import shap

# Train model again if needed
model = RandomForestRegressor()
model.fit(X_train, y_train)

# Create SHAP explainer
explainer = shap.TreeExplainer(model)

# Choose a sample
X_sample = X_test.sample(1, random_state=42)

# Compute SHAP values
shap_values = explainer.shap_values(X_sample)

# Static waterfall plot (works well in Colab)
shap.plots.waterfall(shap.Explanation(
    values=shap_values[0],
    base_values=explainer.expected_value,
    data=X_sample.iloc[0],
    feature_names=X_sample.columns.tolist()
))